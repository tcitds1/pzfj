#### eventloop

 https://zhuanlan.zhihu.com/p/33058983 

#### 第三方cookie

 https://juejin.im/post/5e97124df265da47b27d97ff 

#### 手写promise

 https://juejin.im/post/5dc383bdf265da4d2d1f6b23 

#### 隐式转换



#### domcontentload

 https://zhuanlan.zhihu.com/p/25876048 你不知道的 DOMContentLoaded

 https://zhuanlan.zhihu.com/p/27773098 DOMContentLoaded几种场景分析


https://zhuanlan.zhihu.com/p/22362198 dns prefetch 二三事



#### 性能优化

webpack-bundle-analyze



视频播放

https://www.bilibili.com/read/cv855111/  我们为什么使用DASH



https://juejin.im/post/5d1ea7a8e51d454fd8057bea 为什么视频网站的链接地址是blob



#### 前端缓存

https://www.zhihu.com/question/20790576/answer/32602154 张云龙 大公司怎么部署前端代码的

1.静态资源使用强缓存，cache-control: exprie, 通过更新路径后缀名`a.css?ver=hash`来更新文件,hash根据文件变化来计算。

https://zhuanlan.zhihu.com/p/44789005 一文读懂前端缓存

from memorycache，浏览器预加载的资源会加入memory，`<link rel="preload"`的资源也会加入memory

from disk

##### 按缓存请求分类

* 强缓存

  ​	expires：Thu, 10 Nov 2017 08:45:11 GMT

  ​	cache-control：max-age，must-revalidate， no-cache，no-store（真正意义上的不要缓存），public（所有服务器都缓存），private（仅客户端缓存，代理服务器不能缓存）	

  ​	cache-control 的优先级高于 Expires

* 协商缓存

  服务端写入Last-modify时间，客户端http头携带If-modify-since，如果未过期返回304。

  如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

##### 当浏览器要请求资源时 

1.调用 Service Worker 的 fetch 事件响应 

2.查看 memory cache 

3.查看 disk cache

* 如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200 
* 如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200

##### 常见策略

1.不常变化的资源，Cache-Control: max-age=31536000，更新资源在资源加版本号

2.经常变化的资源，Cache-Control: no-cache



#### 大文件上传和断点续传

https://juejin.im/post/5dff8a26e51d4558105420ed

1.使用`blob.slice`来进行文件分片

2.使用`FormData`和`xhrHttpRequest`发送文件内容

3.通过`xhr.upload.onProgress`来获取文件上传进度

4.通过`xhr.abort`来终止上传

5.服务端合并切片文件



#### Node modules 的困境

https://zhuanlan.zhihu.com/p/137535779

1.如果project依赖的package A 和 package B 依赖了不同版本的package C，npm会按路径自顶向上选择包，优先读取最近的node_modules的依赖。如果project依赖了package D 又依赖了package C，会造成重复安装依赖。

重复依赖导致的问题

* 全局types冲突

* 破坏单例模式
* 使用了flat mode下的p

![img](https://pic2.zhimg.com/80/v2-d8db7577fe6de47821e1874c5a91b351_1440w.jpg)

#### 关于WeakMap的弱引用

weakmap只接受对象作为key值，key值是弱引用。

https://segmentfault.com/a/1190000015774465

#### 首屏加载与白屏时间

https://mp.weixin.qq.com/s/YiKRY_LDURY0uONtEhkUfg

https://increment.com/frontend/making-vue-3/

用load和domcontentload难以衡量页面加载速度，因为不一定与用户看到的内容相对应

后来，业界开始建议使用比如 First Meaningful Paint (FMP) 和 Speed Index (SI)（都可以在 Lighthouse 中获取）等性能指标来帮助捕获初次[渲染](http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=200153364&idx=1&sn=aaf73d88fcbf4ff1a2a7b4de61cbb50a&scene=21&subscene=126#wechat_redirect)后的更多加载体验，但是这些指标非常复杂，难以解释，而且误报率也比较高。

#### why making vue3

1.用typescript，响应式从getter，setter迁移至Proxy

2.解耦内部封装，维护更容易

3.克服virtual dom性能瓶颈，重写了编译器，去掉不必要的virtual dom遍历和比较

4.vue3的大小不到vue2的一半

#### 扒一扒回溯算法的裤子

https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/

#### width 和 flex-basis的区别

https://mastery.games/post/the-difference-between-width-and-flex-basis/#Flex-Items-Formula

#### px和rem的使用

https://www.zhihu.com/question/313971223?utm_source=qq&utm_medium=social&utm_oi=543767149328527360

viewport像素，物理像素，逻辑像素，渲染像素

PT 绝对单位，1pt = 1/72inch

DPR，设备像素/CSS像素比

**window.devicePixelRatio**设备像素物理像素百分比

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">