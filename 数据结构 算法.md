#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度中等442收藏分享切换为英文关注反馈

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

```js
// 递归解法 类似于前序遍历，不同的是把每一行的值存储到二维数组中
var levelOrder = function(root, parent=[], index=0) {
    if (root) {
        parent[index] = parent[index] ? parent[index]: []
        parent[index].push(root.val)
        levelOrder(root.left, parent, index + 1)
        levelOrder(root.right, parent, index + 1)
    }
    return parent
};
// 迭代解法
var levelOrder = function(root) {
  const printArr = []
  if (!root) return printArr
  const list = []
  list.push({ node: root, level: 0 })
  while (list.length > 0) {
    const { node, level } = list.shift()
    if (!printArr[level]) {
      printArr[level] = []
    }
    printArr[level].push(node.val)
    node.left && list.push({ node: node.left, level: level + 1 })
    node.right && list.push({ node: node.right, level: level + 1 })
  }
  return printArr
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/ 

难度简单504收藏分享切换为英文关注反馈

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。BFS

```js
var maxDepth = function(root) {
    if (root !== null) {
        let leftDepth = maxDepth(root.left)
        let rightDepth = maxDepth(root.right)
        return Math.max(leftDepth, rightDepth) + 1
    } else {
        return 0
    }
};
```

压栈出栈

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    var tmpStack = [
        {"key":root,"val":1}
    ];
    var depth = 0;
    while(tmpStack.length != 0){
        var currObj = tmpStack.pop();
        var currNode = currObj.key;
        if(currNode != null){
            var currNode_depth = currObj.val;
            depth = Math.max(depth,currNode_depth);
            if(currNode.left != null){
                tmpStack.push({"key":currNode.left,"val":currNode_depth + 1});
            }
            if(currNode.right != null){
                tmpStack.push({"key":currNode.right,"val":currNode_depth + 1});
            }
        }
    }
    return depth;
};
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度简单724收藏分享切换为英文关注反馈

给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

 

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

```js
// 解题思路 设置check(left, right)
// 2020-5-31复习
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if (!root) return true
    function check(left, right) {
        if (!left && !right) return true
        if (left && right) {
            return left.val === right.val && check(left.right, right.left) && check(left.left, right.right)
        }
        return false
    }
    return check(root.left, root.right)
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

难度简单279收藏分享切换为英文关注反馈

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

```js
// 找到递归中止条件
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if (!root) {
        return false
    }
    if (!root.left && !root.right) {
        return sum - root.val === 0
    }
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)
};
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

难度中等486收藏分享切换为英文关注反馈

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

通过次数77,172

提交次数115,639

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if (!preorder.length) return null
    let root_val = preorder[0]
    let node = new TreeNode(root_val)
    let index = inorder.indexOf(root_val)
    let leftArrays = inorder.slice(0, index)
    let leftArrays_ = preorder.slice(1, index + 1)
    let rightArrays = inorder.slice(index + 1, inorder.length)
    let rightArrays_ = preorder.slice(index + 1, preorder.length)
    node.left = buildTree(leftArrays_, leftArrays)
    node.right = buildTree(rightArrays_, rightArrays)
    return node
};
```



#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

难度中等187收藏分享切换为英文关注反馈

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if (!inorder.length) {
        return null
    }
    let root = new TreeNode(postorder[postorder.length - 1])
    let mid = inorder.indexOf(root.val)
    root.left = buildTree(inorder.slice(0, mid), postorder.slice(0, mid))
    root.right = buildTree(inorder.slice(mid + 1), postorder.slice(mid, postorder.length - 1))
    return root
};
```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度中等158收藏分享切换为英文关注反馈

给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png)

```js
// 判断递归条件，右孩子节点的next指向root的next的zuo'jie'dian
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (root === null || root.left === null) {
        return root
    } 
    root.left.next = root.right
    if (root.next) {
        root.right.next = root.next.left
    }
    connect(root.left)
    connect(root.right)
    return root
};
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度中等468收藏分享切换为英文关注反馈

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

```js
// 如果 p 节点 q 节点分别在左右子树，则root为LCA（lower common ancestor）
// 如果 p 节点 q 节点在同一子树中
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null || root === p || root === q ) {
        return root
    }
    let left = lowestCommonAncestor(root.left, p, q)
    let right = lowestCommonAncestor(root.right, p, q)
    if (left === null && right === null) {
        return null
    }
    if (left !== null && right !== null) {
        return root
    }
    return left === null ? right : left
};

var lowestCommonAncestor = function(root, p, q) {
    let ans = null
    function hasAncestor(root, p, q) {
        if (!root) return false
        let leftIsAns = hasAncestor(root.left, p, q)
        let rightIsAns = hasAncestor(root.right, p, q)
        if ((leftIsAns && rightIsAns) || ((root.val == p.val || root.val === q.val) && (leftIsAns || rightIsAns))) {
            ans = root
        }
        return leftIsAns || rightIsAns || ((root.val === p.val || root.val === q.val))
    }
    hasAncestor(root, p, q)
    return ans
};
```

#### [97. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度困难176收藏分享切换为英文关注反馈

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例:** 

```
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```

```js
// 非递归方法
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    if (root === null) return [];
    let res = [];
    let node = root,
        queue = [node];
    while (queue.length > 0) {
        node = queue.shift();
        if (node === null) {
            res.push(null);
        } else {
            res.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        }
    }
    return res;
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    if (data.length === 0) return null;
    let root = new TreeNode(data.shift());
    let queue = [root];
    while (queue.length > 0) {
        let node = queue.shift();
        // 数组中的节点已经计算完毕
        if (data.length <= 0) break;
        let left = data.shift(); // 左子节点的值
        if (left === null) {
            node.left = null;
        } else {
            node.left = new TreeNode(left);
            queue.push(node.left);
        }
        // 数组中的节点已经计算完毕
        if (data.length <= 0) break;
        let right = data.shift();
        if (right === null) {
            node.right = null;
        } else {
            node.right = new TreeNode(right);
            queue.push(node.right);
        }
    }
    return root;
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

```js
// 递归解法

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    let res = []
    function dfs(node) {
        if (node) {
            res.push(node.val)
            dfs(node.left)
            dfs(node.right)
        } else {
            res.push(null)
        }
    }
    dfs(root)
    return res
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    function dfs() {
        if (data.length === 0 ) {
            return null
        }
        let val = data.shift()
        if (val !== null) {
            let node = new TreeNode(val)
            node.left = dfs()
            node.right = dfs()
            return node
        } else {
            return null
        }
    }
    return dfs()
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

难度中等487收藏分享切换为英文关注反馈

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

![UTOOLS1587992727264.png](https://kurisu1901.oss-cn-shenzhen.aliyuncs.com/UTOOLS1587992727264.png)

```js
// 神特么笛卡尔积 都忘记了好吗！！！
// 利用动态规划G(0) = 1, g(1) = 1
// f(i, n) = g(i-1)*g(n-i)
// 
// 
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  let g = new Array(n + 1).fill(0)
  g[0] = 1;
  g[1] = 1;
  for (let i = 2; i<=n; i++) {
    for (let j = 1; j<=i; j++) {
      g[i] += g[j-1] * g[i-j]
    }
  }
  return g[n]
};

```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */

// 不改变原树方法
// var mergeTrees = function(t1, t2) {
//     let node = null
//     if (t1 || t2) {
//         node = new TreeNode((t1 ? t1.val : 0) + (t2? t2.val: 0))
//         node.left = mergeTrees(t1? t1.left: null, t2? t2.left: null)
//         node.right = mergeTrees(t1? t1.right: null, t2? t2.right: null)
//         return node
//     } else {
//         return null
//     }
// };
// 
var mergeTrees = function(t1, t2) {
    if (t1 && t2) {
        t1.val += t2.val
        t1.lfet = mergeTrees(t1.left, t2.left)
        t1.right = mergeTrees(t1.right, t2.right)
    }
    return t1 || t2
};
```

#### [95. 不同的二叉搜索树 II ](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)hard

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的**二叉搜索树**。

**示例:**

```
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```js
// 奇妙的判定终止方法，注意n===0和左右子树为空的情况的判定
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
  function getRes(start, end) {
    let res = []
    if (start > end) {
      res.push(null)
      return res
    }
    for (let i = start; i <= end; i++) {
      let leftTrees = getRes(start, i - 1)
      let rightTrees = getRes(i + 1, end)
      for (let l of leftTrees) {
        for (let r of rightTrees) {
          let node = new TreeNode(i)
          node.left = l
          node.right = r
          res.push(node)
        }
      }
    }
    return res
  }
  if (n === 0) {
      return []
  } 
  return getRes(1, n)
};
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

难度中等516收藏分享切换为英文关注反馈

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

// 解法 1
// 不仅要确认right > root > left ，而且要记录上一层级的最小值和最大值。
var isValidBST = function(root) {
  function help(node, lower, upper) {
    if (node === null) {
      return true
    } else {
      let val = node.val
      if (lower !== null && val <= lower) return false
      if (upper !== null && val >= upper) return false
      if (!help(node.left, lower, val)) return false
      if (!help(node.right, val, upper)) return false
      return true
    }
  }
  return help(root, null, null)
}

// 根据二叉搜索树的性质，中序遍历的结果为从小到大排列的顺序
// 解法 2
var isValidBST = function(root) {
  function help(node, lower, upper) {
    if (node === null) {
      return true
    } else {
      let val = node.val
      if (lower !== null && val <= lower) return false
      if (upper !== null && val >= upper) return false
      if (!help(node.left, lower, val)) return false
      if (!help(node.right, val, upper)) return false
      return true
    }
  }
  return help(root, null, null)
}

// 解法 3 利用先序遍历，迭代
function isValidBST(root) {
  let stack = []
  let min = Number.MIN_SAFE_INTEGER
  while(stack.length || root !== null) {
    while(root !== null) {
      stack.push(root)
      root = root.left
    }
    root = stack.pop()
    let val = root.val
    if (val <= min) return false
    root = root.right
    min = val
  }
  return true
}

```



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等331收藏分享切换为英文关注反馈

给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */

// 将左子树的最后一个右节点.ritht->root.right,root.right = root.left, root.left = null,
var flatten = function(root) {
    while (root !== null) {
        if (root.left === null) {
            root = root.right
        } else {
            let pre = root.left
            while (pre.right !== null) {
                pre = pre.right
            }
            pre.right = root.right
            root.right = root.left
            root.left = null
            root = root.right
        }
    }
};

// 利用中序遍历stack的方法，记录上一个节点
var flatten = function(root) {
  if (root === null) return
  let stack = []
  let pre = null
  stack.push(root)
  while(stack.length) {
    let temp = stack.pop()
    if (pre !== null) {
      pre.right = temp
      pre.left = null
    }
    if (temp.right !== null) {
      stack.push(temp.right)
    }
    if (temp.left !== null) {
      stack.push(temp.left)
    }
    pre = temp
  }
}
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

难度困难406收藏分享切换为英文关注反馈

给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例 2:**

```js
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```

```js
// 创造一个函数，获取通过该节点的单路径的最大路径和
var pathSum = function(root, sum) {
    // 以自己作为起始节点 有多少条路径和 = sum
    function getsum(root, sum) {
        let result = 0;
        if (root === null) return 0
        sum -= root.val;
        if (sum === 0) result++
        return (result + getsum(root.left, sum) + getsum(root.right, sum))
    }
    // 遍历每一个节点作为起始节点并作为路径和 
    function getTotalSum(root, sum) {
        if (root) {
            return getsum(root, sum) + getTotalSum(root.left, sum) + getTotalSum(root.right, sum)
        }
        return 0  
    }

    return getTotalSum(root, sum)
};
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) easy

难度简单419收藏分享切换为英文关注反馈

翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**备注:**
这个问题是受到 [Max Howell ](https://twitter.com/mxcl)的 [原问题](https://twitter.com/mxcl/status/608682016205344768) 启发的 ：

> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

```js
// 难得有一下就写出来的题目
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (root !== null) {
        invertTree(root.left)
        invertTree(root.right)
        let temp = root.left
        root.left = root.right
        root.right = temp
    }
    return root
};
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

难度中等329收藏分享切换为英文关注反馈

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

```js
// 抢爷孙还是抢爹
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
    let map = new WeakMap()
    function maxV(root) {
        if (map.get(root)) return map.get(root)
        if (root === null) return 0
        let money = root.val
        if (root.left !== null) {
            money += maxV(root.left.left) + maxV(root.left.right)
        }
        if (root.right !== null) {
            money += maxV(root.right.left) + maxV(root.right.right)
        }
        let result = Math.max(maxV(root.left) + maxV(root.right), money)
        map.set(root, result)
        return result
    }
    return maxV(root)
};
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

**示例：**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

```js
// 双递归 我太蠢了 草
// 自己作为头结点的路径和，然后遍历所有节点
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, sum) {
    // 以自己作为头节点的个数
    function getsum(root, sum) {
        let result = 0;
        if (root === null) return 0
        sum -= root.val;
        if (sum === 0) result++
        return (result + getsum(root.left, sum) + getsum(root.right, sum))
    }
    function getTotalSum(root, sum) {
        if (root) {
            return getsum(root, sum) + getTotalSum(root.left, sum) + getTotalSum(root.right, sum)
        }
        return 0  
    }
    return getTotalSum(root, sum)
};
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

 

**例如：**

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

```js
// 利用二叉搜索树的特性，右>中>左，将前序遍历倒一下
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
    let sum = 0;
    function add(root) {
        if (root !== null) {
            add(root.right)
            sum += root.val
            root.val = sum
            add(root.left)
            return root
        } else {
            return null
        }
    }
    return add(root)
};
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

难度简单339收藏分享切换为英文关注反馈

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

```js
// 计算节点深度，最长路径 = 左子树深度 + 右子树深度
// 计算每个节点的max_deepth，max = left_max_deepth + right_max_deepth
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    // L + R + 1
    let max = 0
    function maxPath(root) {
        if (root !== null) {
            let maxL = maxPath(root.left)
            let maxR = maxPath(root.right)
            max = Math.max(max, maxL + maxR)
            return Math.max(maxL, maxR) + 1
        } else {
            return 0
        }
    }
    maxPath(root)
    return max
};
```

#### [2. 两数相加(进位)](https://leetcode-cn.com/problems/add-two-numbers/)

难度中等4293

给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```js
// 考察进位制
var addTwoNumbers = function(l1, l2) {
  // 进位
  let count = 0;
  let node = new ListNode('')
  let p = node
  while (l1 || l2 || count) {
    let l1_val = l1 ? l1.val : 0;
    let l2_val = l2 ? l2.val : 0;
    let sum = l1_val + l2_val + count
    p.next = new ListNode('')
    p = p.next
    if (sum >= 10) {
      count = 1
      p.val = sum % 10
    } else {
      count = 0
      p.val = sum
    }
    if (l1) l1 = l1.next
    if (l2) l2 = l2.next
  }
  return node.next
};
```

#### [3. 无重复字符的最长子串(滑动指针)](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度中等3623收藏分享切换为英文关注反馈

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```js
/**
 * @param {string} s
 * @return {number}
 */
// 暴力
// var lengthOfLongestSubstring = function(s) {
//     let max = 0;
//     let res = []
//     for (let i = 0; i < s.length; i++) {
//         for (let j = i; j < s.length; j++) {
//             if (res.indexOf(s[j]) === -1) {
//                 res.push(s[j])
//             } else {
//                 break
//             }
//         }
//         max = Math.max(max, res.length)
//         res = []
//     }
//     return max
// };

// 维护下标
// var lengthOfLongestSubstring = function(str) {
//   let max = 0;
//   let index = -1;
//   for (let i = 0, j = 0; j < str.length; j++) {
//     index = str.slice(i, j).indexOf(str[j])
//     if (index !== -1) {
//       i = i + index + 1
//     }
//     max = Math.max(max, j - i + 1)
//   }
//   return max
// };

// 维护数组
function lengthOfLongestSubstring(str) {
  let res = []
  let right = 0;
  let max = 0
  for (; right < str.length; right++) {
    let index = res.indexOf(str[right])
    if (index !== -1) {
      res.splice(0, index + 1)
    }
    res.push(str[right])
    max = Math.max(max,res.length)
  }
  console.log(max)
  return max
}

```



#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

难度中等374收藏分享切换为英文关注反馈

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  function doubleP(x, n) {
    if (n === 0) {
      return 1
    }
    if (n === 1) {
      return x
    }
    let n2 = Math.floor(n / 2)
    let n2Val = doubleP(x, n2)
    return n % 2 === 0 ? n2Val * n2Val : n2Val * n2Val * x
  }
  if (n >= 0) {
    return doubleP(x, n)
  } else {
    return doubleP(1/x, -n)
  }
};
```

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

难度简单8209收藏分享切换为英文关注反馈

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

 

**示例:**

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```
// 暴力法和一遍哈希存储法
```



#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

难度中等2113收藏分享切换为英文关注反馈

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```

```js
// 中心拓展法，比较奇数为中心和偶数为中心的回文结果
// 动态规划法 还没看 5.13
/**
 * @param {string} s
 * @return {string}
 */
// 注意边界 left >= 0 right < length slice(left + 1, right)
var longestPalindrome = function(s) {
    function expandStr(s, left, right) {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--
            right++
        }
        return s.slice(left + 1, right)
    }
    if (!s.length) return ""
    let maxStr = ''
    for (let i = 0; i < s.length; i++) {
        let oddVal = expandStr(s, i, i)
        let evenVal = expandStr(s, i, i + 1)
        let max = oddVal.length > evenVal.length ? oddVal : evenVal
        maxStr = max.length > maxStr.length ? max : maxStr
    }
    return maxStr
};
```

#### [560.152.974 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

难度中等422收藏分享切换为英文关注反馈

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

**示例 1 :**

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

**说明 :**

1. 数组的长度为 [1, 20,000]。
2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

```js
// 前缀和 pre[j] - pre[i - 1] = k ，利用这个规则+hashmap
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */

var subarraySum = function(nums, k) {
    let map = new Map()
    map.set(0, 1)
    let count = 0;
    let preSum = 0;
    for (let num of nums) {
        preSum += num
        if (map.has(preSum - k)) count+= map.get(preSum - k)
        if (map.has(preSum)) {
            map.set(preSum, map.get(preSum) + 1)
        } else {
            map.set(preSum, 1)
        }
    }
    return count
};
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

难度中等148收藏分享切换为英文关注反馈

现在你总共有 *n* 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1:**

```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2:**

```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明:**

1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。

**提示:**

1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索) 完成。

```js
// 把一个有向无环图变成线性排序就是拓扑排序
// 1.构建入度数组
// 2.构建出度hash表，如果[2, 0], [1, 0] => 0: [1, 2]
// 3.构建队列queue,将入度为0的都push进queue
// 4.cur = queue.pop(),检查cur在hash表中对应的出度数组，并元素对应入度数组中的item-1,如果为0，push进queue

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = (numCourses, prerequisites) => {
  let inDegree = new Array(numCourses).fill(0) // 入度数组
  let graph = {} // 哈希表
  for (let i = 0; i < prerequisites.length; i++) {
    inDegree[prerequisites[i][0]]++ // 构建入度数组
    if (graph[prerequisites[i][1]]) { // 构建哈希表
      graph[prerequisites[i][1]].push(prerequisites[i][0])
    } else {
      let list = []
      list.push(prerequisites[i][0])
      graph[prerequisites[i][1]] = list
    }
  }
  let res = [] // 结果数组
  let queue = [] // 存 入度为0的课
  for (let i = 0; i < numCourses; i++) { // 初始时，推入所有入度为0的课
    if (inDegree[i] === 0) queue.push(i)
  }
  while (queue.length) { // 没有了入度为0的课，没课可选，结束循环
    let cur = queue.shift() // 出栈，代表选这门课
    res.push(cur) // 推入结果数组
    let toEnQueue = graph[cur] // 查看哈希表，获取对应的后续课程
    if (toEnQueue && toEnQueue.length) { // 确保有后续课程
      for (let i = 0; i < toEnQueue.length; i++) { // 遍历后续课程
        inDegree[toEnQueue[i]]-- // 将后续课程的入度 -1
        if (inDegree[toEnQueue[i]] == 0) { // 一旦减到0，让该课入列
          queue.push(toEnQueue[i])
        }
      }
    }
  }
  return res.length === numCourses ? res : [] // 选满了就返回res，否则返回[]
};

```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度简单959

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

通过次数236,161

提交次数342,498

```js
// 第一个last节点是null，缓存head.next
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if (head !== null) {
        let p = head
        let last = null
        while(p) {
            let cur = p.next
            p.next = last
            last = p
            p = cur
        }
        return last
    }
    return head
};
```

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

难度中等543

在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1:**

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2:**

```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

通过次数60,904

提交次数93,158

```js
// 归并排序
var sortList = function(head) {
  if (head == null || head.next === null) {
    return head
  }
  let fastNode = head.next
  let slowNode = head
  while (fastNode && fastNode.next) {
    slowNode = slowNode.next
    fastNode = fastNode.next.next
  }
  let right = slowNode.next
  slowNode.next = null
  let l = sortList(head)
  let r = sortList(right)
  let p = new ListNode('')
  let point = p
  while (l && r) {
    if (l.val <= r.val) {
      point.next = new ListNode(l.val)
      l = l.next
    } else {
      point.next = new ListNode(r.val)
      r = r.next
    }
    point = point.next
  }
  point.next = l ? l : r
  return p.next
};
```

#### [152. 乘积最大子数组(还有一种解法)](https://leetcode-cn.com/problems/maximum-product-subarray/)

难度中等569

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

```js
// 按照0拆分
var maxProduct = function(nums) {
  let sum = 1;
  let max = Number.MIN_SAFE_INTEGER;
  for (let num of nums) {
    sum *= num
    if (max < sum) max = sum
    if (sum === 0) sum = 1
  }
  sum = 1
  for (let i = nums.length - 1; i >= 0; i--) {
    sum *= nums[i]
    if (max < sum) max = sum
    if (sum === 0) sum = 1
  }
  return max
};
// 动态规划
var maxProduct = (nums) => {
  let min = nums[0];
  let max = nums[0];
  let last = nums[0]
  for (let i = 1; i < nums.length; i++) {
    let temp1 = min * nums[i]
    let temp2 = max * nums[i]
    min = Math.min(temp1, temp2, nums[i])
    max = Math.max(temp1, temp2, nums[i])
    console.log(min)
    console.log(max)
    last = Math.max(last, max)
  }
  return last
}
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

难度中等816收藏分享切换为英文关注反馈

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
// 找到倒数第n + 1个节点
var removeNthFromEnd = function(head, n) {
    let fast = head
    let slow = head
    while(n > 0) {
        fast = fast.next
        n--
    }
    while(fast && fast.next) {
        fast = fast.next
        slow = slow.next
    }
  	// 倒数第一个节点
    if (fast === null) {
        return head.next
    }
    slow.next = slow.next.next
    return head
};
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度简单598收藏分享切换为英文关注反馈

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

 

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3：**

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

 

**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */

// 1. 利用hashmap
// var hasCycle = function(head) {
//   if (!head || !head.next) return false
//   let map =new Map()
//   while(head) {
//     let p = map.get(head)
//     if (p) return true
//     map.set(head, 1)
//     head = head.next
//   }
//   return false
// };

// 2. 利用快慢指针
var hasCycle = function(head) {
  if (!head || !head.next) return false
  let slow = head
  let fast = head.next
  while(fast && fast.next) {
      if (fast === slow) {
          return true
      }
      fast = fast.next.next
      slow = slow.next
  }
  return false
};
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

难度简单664收藏分享切换为英文关注反馈

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

 

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

 

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

 ```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
// 方法1 暴力
// 方法2 hash表方法
// 方法3 双指针
// 错的人迟早会走散，而对的人迟早会相逢！ a+c+b = b + c + a
var getIntersectionNode = function(headA, headB) {
  let pointA = headA
  let pointB = headB
  while (pointA !== pointB) {
    pointA = pointA ? pointA.next : headB
    pointB = pointB ? pointB.next : headA
  }
  return pointA
};
 ```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

难度中等482

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**说明：**不允许修改给定的链表。

 

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3：**

```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

![image.png](https://kurisu1901.oss-cn-shenzhen.aliyuncs.com/picgo/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png)

```js
// 快慢指针 理解有点问题
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
  if (head === null || head.next === null) return null
  let slow = head
  let fast = head
  while(fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
    if (slow === fast) {
      fast = head
      while (fast !== slow) {
        fast = fast.next
        slow = slow.next
      }
      return slow
    }
  }
  return null
};


```

#### [394. 字符串解码(一个栈的解法比较简单）](https://leetcode-cn.com/problems/decode-string/)

难度中等357收藏分享切换为英文关注反馈

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例:**

```
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
```

通过次数44,717

提交次数84,929

```js
// 用一个栈 push num、str、'['、 遇到 ']'开始出栈
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function(s) {
    let stack = []
    for (let st of s) {
        if (st !== ']') {
            stack.push(st)
            continue
        }
        let str = ''
        let cur = stack.pop()
        while (cur !== '[') {
            str = cur + str
            cur = stack.pop()
        }
        let num = ''
        cur = stack.pop()
        while (!isNaN(cur)) {
            num = cur + num
            cur = stack.pop()
        }
        let result = str.repeat(num)
        stack.push(cur)
        stack.push(result)
    }
    return stack.join('')
};

// 容易写错的解法
var decodeString = (s) => {
  let numStack = [] // 倍数num的等待栈
  let strStack = [] // 待拼接的str的等待栈
  let num = 0       // 倍数的“搬运工”
  let result = ''   // 字符串的“搬运工”
  for (const char of s) {      // 向右逐字符扫描
    if (!isNaN(char)) {        // 遇到数字
      num = num * 10 + +char   // js中+可以将数字字符转为数字
    } else if (char === '[') { // 入栈的时机
      strStack.push(result)    // result进入strStack栈等待
      result = ''              // 完成进栈后 清零
      numStack.push(num)       // 倍数num进入栈等待
      num = 0                  // 完成进栈后 清零
    } else if (char === ']') { // 出栈的时机，两个栈的栈顶出栈
      let repeatTimes = numStack.pop() // 获取拷贝次数
      result = strStack.pop() + result.repeat(repeatTimes) // 构建子串
    } else {                   // 遇到字母，追加给result串
      result += char
    }
  }
  return result 
}
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

难度简单1590收藏分享切换为英文关注反馈

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```

```js
/**
 * @param {string} s
 * @return {boolean}
 */
// 中间两边法 [[{}]] 最中间总是有相邻的括号
var isValid = function(s) {
    let dic = {
        ']': '[',
        ')': '(',
        '}': '{'
    }
    let pre = ''
    let stack = []
    for (let st of s) {
        if (!dic[st]) {
            stack.push(st)
        } else {
            let p = stack.pop()
            if (dic[st] !== p) return false
        }
    }
    return !stack.length
};
```

#### [面试题64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

难度中等111

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

 

**示例 1：**

```
输入: n = 3
输出: 6
```

**示例 2：**

```
输入: n = 9
输出: 45
```

 

**限制：**

- `1 <= n <= 10000`

```
// 利用 && + 递归
// 位运算
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

难度困难1313

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

```js
1.暴力解法
2.动态规划 最短的板子减去自身的板子
var trap = function(height) {
    let res = 0;
    let n = height.length
    let leftMax = []
    let rightMax = []
    let max = 0;
    for (let i = 0; i < n; i++) {
        leftMax[i] = max = Math.max(height[i], max)
    }
    max = 0
    for (let j = n - 1 ; j >= 0; j--) {
        rightMax[j] = max = Math.max(height[j], max)
    }
    for (let i = 0; i < n; i ++) {
        res += Math.min(leftMax[i], rightMax[i]) - height[i]
    }
    return res
};
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

难度中等469

给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

 

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

 

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。

**进阶：**
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  var left = [1]
  var right = []
  right[nums.length - 1] = 1
  for (let i = 1; i < nums.length; i++) {
    left[i] = left[i - 1] * nums[i - 1]
  }
  for (let i = nums.length - 2; i >= 0; i--) {
    right[i] = right[i + 1] * nums[i + 1]
  }
  let result = []
  for (let i = 0; i < nums.length; i++) {
    result.push(left[i] * right[i])
  }
  return result
};
```

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

难度中等385收藏分享切换为英文关注反馈

给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例 1:**

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
```

**示例 2:**

```
输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
```

```js
// 螺旋矩阵 l r t b
var spiralOrder = function(matrix) {
  if (!matrix.length) return []
  let res = []
  let l = 0, r = matrix.length - 1; t = 0, b = matrix.length - 1;
  while (true) {
    for (let i = l; i <= r; i++) {
      res.push(matrix[t][i])
    }
    if (++t > b) break
    for (let i = t; i <= b; i++) {
      res.push(matrix[i][r])
    }
    if (--r < l) break
    for (let i = r; i >= l; i--) {
      res.push(matrix[b][i])
    }
    if (--b < t) break
    for (let i = b; i >= t; i--) {
      res.push(matrix[i][l])
    }
    if (++l > r) break
  }
  return res
};
```

