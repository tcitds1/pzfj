#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度中等442收藏分享切换为英文关注反馈

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

```js
// 递归解法 类似于前序遍历，不同的是把每一行的值存储到二维数组中
var levelOrder = function(root, parent=[], index=0) {
    if (root) {
        parent[index] = parent[index] ? parent[index]: []
        parent[index].push(root.val)
        levelOrder(root.left, parent, index + 1)
        levelOrder(root.right, parent, index + 1)
    }
    return parent
};
// 迭代解法
var levelOrder = function(root) {
  const printArr = []
  if (!root) return printArr
  const list = []
  list.push({ node: root, level: 0 })
  while (list.length > 0) {
    const { node, level } = list.shift()
    if (!printArr[level]) {
      printArr[level] = []
    }
    printArr[level].push(node.val)
    node.left && list.push({ node: node.left, level: level + 1 })
    node.right && list.push({ node: node.right, level: level + 1 })
  }
  return printArr
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/ 

难度简单504收藏分享切换为英文关注反馈

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。BFS

```js
var maxDepth = function(root) {
    if (root !== null) {
        let leftDepth = maxDepth(root.left)
        let rightDepth = maxDepth(root.right)
        return Math.max(leftDepth, rightDepth) + 1
    } else {
        return 0
    }
};
```

压栈出栈

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    var tmpStack = [
        {"key":root,"val":1}
    ];
    var depth = 0;
    while(tmpStack.length != 0){
        var currObj = tmpStack.pop();
        var currNode = currObj.key;
        if(currNode != null){
            var currNode_depth = currObj.val;
            depth = Math.max(depth,currNode_depth);
            if(currNode.left != null){
                tmpStack.push({"key":currNode.left,"val":currNode_depth + 1});
            }
            if(currNode.right != null){
                tmpStack.push({"key":currNode.right,"val":currNode_depth + 1});
            }
        }
    }
    return depth;
};
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度简单724收藏分享切换为英文关注反馈

给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

 

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

```js
// 解题思路
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if (root === null) {
        return true
    } else {
        return a(root.left, root.right)
    }
    function a(left, right) {
        if (!left && !right) {
            return true
        }
        if (!left || !right) {
            return false
        }
        return left.val === right.val && a(left.left, right.right) && a(left.right, right.left)
    }
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

难度简单279收藏分享切换为英文关注反馈

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

```js
// 找到递归中止条件
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if (!root) {
        return false
    }
    if (!root.left && !root.right) {
        return sum - root.val === 0
    }
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)
};
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

难度中等187收藏分享切换为英文关注反馈

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if (!inorder.length) {
        return null
    }
    let root = new TreeNode(postorder[postorder.length - 1])
    let mid = inorder.indexOf(root.val)
    root.left = buildTree(inorder.slice(0, mid), postorder.slice(0, mid))
    root.right = buildTree(inorder.slice(mid + 1), postorder.slice(mid, postorder.length - 1))
    return root
};
```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度中等158收藏分享切换为英文关注反馈

给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png)

```js
// 判断递归条件，右孩子节点的next指向root的next的zuo'jie'dian
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (root === null || root.left === null) {
        return root
    } 
    root.left.next = root.right
    if (root.next) {
        root.right.next = root.next.left
    }
    connect(root.left)
    connect(root.right)
    return root
};
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度中等468收藏分享切换为英文关注反馈

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

```js
// 如果 p 节点 q 节点分别在左右子树，则root为LCA（lower common ancestor）
// 如果 p 节点 q 节点在同一子树中
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null || root === p || root === q ) {
        return root
    }
    let left = lowestCommonAncestor(root.left, p, q)
    let right = lowestCommonAncestor(root.right, p, q)
    if (left === null && right === null) {
        return null
    }
    if (left !== null && right !== null) {
        return root
    }
    return left === null ? right : left
};

var lowestCommonAncestor = function(root, p, q) {
    let ans = null
    function hasAncestor(root, p, q) {
        if (!root) return false
        let leftIsAns = hasAncestor(root.left, p, q)
        let rightIsAns = hasAncestor(root.right, p, q)
        if ((leftIsAns && rightIsAns) || ((root.val == p.val || root.val === q.val) && (leftIsAns || rightIsAns))) {
            ans = root
        }
        return leftIsAns || rightIsAns || ((root.val === p.val || root.val === q.val))
    }
    hasAncestor(root, p, q)
    return ans
};
```

#### [97. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度困难176收藏分享切换为英文关注反馈

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例:** 

```
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```

```js
// 非递归方法
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    if (root === null) return [];
    let res = [];
    let node = root,
        queue = [node];
    while (queue.length > 0) {
        node = queue.shift();
        if (node === null) {
            res.push(null);
        } else {
            res.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        }
    }
    return res;
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    if (data.length === 0) return null;
    let root = new TreeNode(data.shift());
    let queue = [root];
    while (queue.length > 0) {
        let node = queue.shift();
        // 数组中的节点已经计算完毕
        if (data.length <= 0) break;
        let left = data.shift(); // 左子节点的值
        if (left === null) {
            node.left = null;
        } else {
            node.left = new TreeNode(left);
            queue.push(node.left);
        }
        // 数组中的节点已经计算完毕
        if (data.length <= 0) break;
        let right = data.shift();
        if (right === null) {
            node.right = null;
        } else {
            node.right = new TreeNode(right);
            queue.push(node.right);
        }
    }
    return root;
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

```js
// 递归解法

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    let res = []
    function dfs(node) {
        if (node) {
            res.push(node.val)
            dfs(node.left)
            dfs(node.right)
        } else {
            res.push(null)
        }
    }
    dfs(root)
    return res
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    function dfs() {
        if (data.length === 0 ) {
            return null
        }
        let val = data.shift()
        if (val !== null) {
            let node = new TreeNode(val)
            node.left = dfs()
            node.right = dfs()
            return node
        } else {
            return null
        }
    }
    return dfs()
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

难度中等487收藏分享切换为英文关注反馈

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

![UTOOLS1587992727264.png](https://kurisu1901.oss-cn-shenzhen.aliyuncs.com/UTOOLS1587992727264.png)

```js
// 神特么笛卡尔积 都忘记了好吗！！！
// 利用动态规划G(0) = 1, g(1) = 1
// f(i, n) = g(i-1)*g(n-i)
// 
// 
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  let g = new Array(n + 1).fill(0)
  g[0] = 1;
  g[1] = 1;
  for (let i = 2; i<=n; i++) {
    for (let j = 1; j<=i; j++) {
      g[i] += g[j-1] * g[i-j]
    }
  }
  return g[n]
};

```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */

// 不改变原树方法
// var mergeTrees = function(t1, t2) {
//     let node = null
//     if (t1 || t2) {
//         node = new TreeNode((t1 ? t1.val : 0) + (t2? t2.val: 0))
//         node.left = mergeTrees(t1? t1.left: null, t2? t2.left: null)
//         node.right = mergeTrees(t1? t1.right: null, t2? t2.right: null)
//         return node
//     } else {
//         return null
//     }
// };
// 
var mergeTrees = function(t1, t2) {
    if (t1 && t2) {
        t1.val += t2.val
        t1.lfet = mergeTrees(t1.left, t2.left)
        t1.right = mergeTrees(t1.right, t2.right)
    }
    return t1 || t2
};
```

#### [95. 不同的二叉搜索树 II ](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)hard

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的**二叉搜索树**。

**示例:**

```
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```js
// 奇妙的判定终止方法，注意n===0和左右子树为空的情况的判定
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
  function getRes(start, end) {
    let res = []
    if (start > end) {
      res.push(null)
      return res
    }
    for (let i = start; i <= end; i++) {
      let leftTrees = getRes(start, i - 1)
      let rightTrees = getRes(i + 1, end)
      for (let l of leftTrees) {
        for (let r of rightTrees) {
          let node = new TreeNode(i)
          node.left = l
          node.right = r
          res.push(node)
        }
      }
    }
    return res
  }
  if (n === 0) {
      return []
  } 
  return getRes(1, n)
};
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

难度中等516收藏分享切换为英文关注反馈

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

// 解法 1
// 不仅要确认right > root > left ，而且要记录上一层级的最小值和最大值。
var isValidBST = function(root) {
  function help(node, lower, upper) {
    if (node === null) {
      return true
    } else {
      let val = node.val
      if (lower !== null && val <= lower) return false
      if (upper !== null && val >= upper) return false
      if (!help(node.left, lower, val)) return false
      if (!help(node.right, val, upper)) return false
      return true
    }
  }
  return help(root, null, null)
}

// 根据二叉搜索树的性质，中序遍历的结果为从小到大排列的顺序
// 解法 2
var isValidBST = function(root) {
  function help(node, lower, upper) {
    if (node === null) {
      return true
    } else {
      let val = node.val
      if (lower !== null && val <= lower) return false
      if (upper !== null && val >= upper) return false
      if (!help(node.left, lower, val)) return false
      if (!help(node.right, val, upper)) return false
      return true
    }
  }
  return help(root, null, null)
}

// 解法 3 利用先序遍历，迭代
function isValidBST(root) {
  let stack = []
  let min = Number.MIN_SAFE_INTEGER
  while(stack.length || root !== null) {
    while(root !== null) {
      stack.push(root)
      root = root.left
    }
    root = stack.pop()
    let val = root.val
    if (val <= min) return false
    root = root.right
    min = val
  }
  return true
}

```



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等331收藏分享切换为英文关注反馈

给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */

// 将左子树的最后一个右节点.ritht->root.right,root.right = root.left, root.left = null,
var flatten = function(root) {
    while (root !== null) {
        if (root.left === null) {
            root = root.right
        } else {
            let pre = root.left
            while (pre.right !== null) {
                pre = pre.right
            }
            pre.right = root.right
            root.right = root.left
            root.left = null
            root = root.right
        }
    }
};

// 利用中序遍历stack的方法，记录上一个节点
var flatten = function(root) {
  if (root === null) return
  let stack = []
  let pre = null
  stack.push(root)
  while(stack.length) {
    let temp = stack.pop()
    if (pre !== null) {
      pre.right = temp
      pre.left = null
    }
    if (temp.right !== null) {
      stack.push(temp.right)
    }
    if (temp.left !== null) {
      stack.push(temp.left)
    }
    pre = temp
  }
}
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

难度困难406收藏分享切换为英文关注反馈

给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例 2:**

```js
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```

```js
// 创造一个函数，获取通过该节点的单路径的最大路径和
var pathSum = function(root, sum) {
    // 以自己作为起始节点 有多少条路径和 = sum
    function getsum(root, sum) {
        let result = 0;
        if (root === null) return 0
        sum -= root.val;
        if (sum === 0) result++
        return (result + getsum(root.left, sum) + getsum(root.right, sum))
    }
    // 遍历每一个节点作为起始节点并作为路径和 
    function getTotalSum(root, sum) {
        if (root) {
            return getsum(root, sum) + getTotalSum(root.left, sum) + getTotalSum(root.right, sum)
        }
        return 0  
    }

    return getTotalSum(root, sum)
};
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) easy

难度简单419收藏分享切换为英文关注反馈

翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**备注:**
这个问题是受到 [Max Howell ](https://twitter.com/mxcl)的 [原问题](https://twitter.com/mxcl/status/608682016205344768) 启发的 ：

> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

```js
// 难得有一下就写出来的题目
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (root !== null) {
        invertTree(root.left)
        invertTree(root.right)
        let temp = root.left
        root.left = root.right
        root.right = temp
    }
    return root
};
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

难度中等329收藏分享切换为英文关注反馈

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

```js
// 抢爷孙还是抢爹
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
    let map = new WeakMap()
    function maxV(root) {
        if (map.get(root)) return map.get(root)
        if (root === null) return 0
        let money = root.val
        if (root.left !== null) {
            money += maxV(root.left.left) + maxV(root.left.right)
        }
        if (root.right !== null) {
            money += maxV(root.right.left) + maxV(root.right.right)
        }
        let result = Math.max(maxV(root.left) + maxV(root.right), money)
        map.set(root, result)
        return result
    }
    return maxV(root)
};
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

**示例：**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

```js
// 双递归 我太蠢了 草
// 自己作为头结点的路径和，然后遍历所有节点
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, sum) {
    // 以自己作为头节点的个数
    function getsum(root, sum) {
        let result = 0;
        if (root === null) return 0
        sum -= root.val;
        if (sum === 0) result++
        return (result + getsum(root.left, sum) + getsum(root.right, sum))
    }
    function getTotalSum(root, sum) {
        if (root) {
            return getsum(root, sum) + getTotalSum(root.left, sum) + getTotalSum(root.right, sum)
        }
        return 0  
    }
    return getTotalSum(root, sum)
};
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

 

**例如：**

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

```js
// 利用二叉搜索树的特性，右>中>左，将前序遍历倒一下
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
    let sum = 0;
    function add(root) {
        if (root !== null) {
            add(root.right)
            sum += root.val
            root.val = sum
            add(root.left)
            return root
        } else {
            return null
        }
    }
    return add(root)
};
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

难度简单339收藏分享切换为英文关注反馈

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

```js
// 计算节点深度，最长路径 = 左子树深度 + 右子树深度
// 计算每个节点的max_deepth，max = left_max_deepth + right_max_deepth
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    // L + R + 1
    let max = 0
    function maxPath(root) {
        if (root !== null) {
            let maxL = maxPath(root.left)
            let maxR = maxPath(root.right)
            max = Math.max(max, maxL + maxR)
            return Math.max(maxL, maxR) + 1
        } else {
            return 0
        }
    }
    maxPath(root)
    return max
};
```

#### [2. 两数相加(进位)](https://leetcode-cn.com/problems/add-two-numbers/)

难度中等4293

给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```js
// 考察进位制
var addTwoNumbers = function(l1, l2) {
  // 进位
  let count = 0;
  let node = new ListNode('')
  let p = node
  while (l1 || l2 || count) {
    let l1_val = l1 ? l1.val : 0;
    let l2_val = l2 ? l2.val : 0;
    let sum = l1_val + l2_val + count
    p.next = new ListNode('')
    p = p.next
    if (sum >= 10) {
      count = 1
      p.val = sum % 10
    } else {
      count = 0
      p.val = sum
    }
    if (l1) l1 = l1.next
    if (l2) l2 = l2.next
  }
  return node.next
};
```

#### [3. 无重复字符的最长子串(滑动指针)](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度中等3623收藏分享切换为英文关注反馈

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```js
/**
 * @param {string} s
 * @return {number}
 */
// 暴力
// var lengthOfLongestSubstring = function(s) {
//     let max = 0;
//     let res = []
//     for (let i = 0; i < s.length; i++) {
//         for (let j = i; j < s.length; j++) {
//             if (res.indexOf(s[j]) === -1) {
//                 res.push(s[j])
//             } else {
//                 break
//             }
//         }
//         max = Math.max(max, res.length)
//         res = []
//     }
//     return max
// };

// 维护下标
// var lengthOfLongestSubstring = function(str) {
//   let max = 0;
//   let index = -1;
//   for (let i = 0, j = 0; j < str.length; j++) {
//     index = str.slice(i, j).indexOf(str[j])
//     if (index !== -1) {
//       i = i + index + 1
//     }
//     max = Math.max(max, j - i + 1)
//   }
//   return max
// };

// 维护数组
function lengthOfLongestSubstring(str) {
  let res = []
  let right = 0;
  let max = 0
  for (; right < str.length; right++) {
    let index = res.indexOf(str[right])
    if (index !== -1) {
      res.splice(0, index + 1)
    }
    res.push(str[right])
    max = Math.max(max,res.length)
  }
  console.log(max)
  return max
}

```



#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

难度中等374收藏分享切换为英文关注反馈

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  function doubleP(x, n) {
    if (n === 0) {
      return 1
    }
    if (n === 1) {
      return x
    }
    let n2 = Math.floor(n / 2)
    let n2Val = doubleP(x, n2)
    return n % 2 === 0 ? n2Val * n2Val : n2Val * n2Val * x
  }
  if (n >= 0) {
    return doubleP(x, n)
  } else {
    return doubleP(1/x, -n)
  }
};
```

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

难度简单8209收藏分享切换为英文关注反馈

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

 

**示例:**

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```
// 暴力法和一遍哈希存储法
```



#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

难度中等2113收藏分享切换为英文关注反馈

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```

```js
// 中心拓展法，比较奇数为中心和偶数为中心的回文结果
// 动态规划法 还没看 5.13
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    function expandStr(s, left, right) {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--
            right++
        }
        return s.slice(left + 1, right)
    }
    if (!s.length) return ""
    let maxStr = ''
    for (let i = 0; i < s.length; i++) {
        let oddVal = expandStr(s, i, i)
        let evenVal = expandStr(s, i, i + 1)
        let max = oddVal.length > evenVal.length ? oddVal : evenVal
        maxStr = max.length > maxStr.length ? max : maxStr
    }
    return maxStr
};
```

